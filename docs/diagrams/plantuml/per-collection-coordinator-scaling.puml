@startuml per-collection-coordinator-scaling
!theme blueprint
title Per-Collection StorageIndexCoordinator Scaling Architecture

!define COLLECTION_COLOR #E8F4FD
!define COORDINATOR_COLOR #FFF2CC
!define STORAGE_COLOR #F8CECC
!define AXIS_COLOR #D5E8D4
!define WAL_COLOR #FFE6CC

package "UnifiedAvroService Layer" {
    component [UnifiedAvroService] as UAS {
        note right: Manages service-level operations\nand coordinator lifecycle
    }
    
    component [StorageIndexCoordinatorManager] as SCM <<Singleton>> {
        + get_or_create_coordinator()
        + remove_coordinator()
        + get_aggregate_metrics()
        --
        coordinators: HashMap<String, Arc<Coordinator>>
        axis_manager: Arc<AxisIndexManager>
        viper_engine: Arc<ViperCoreEngine>
        lsm_engine: Arc<LsmTree>
    }
}

package "Per-Collection Coordination" {
    component [CollectionStorageIndexCoordinator\n(Collection A)] as CA <<Per-Collection>> COORDINATOR_COLOR {
        + handle_vector_insertion()
        + handle_flush_completion()
        + handle_compaction_completion()
        + get_metrics()
        --
        collection_id: "collection_a"
        storage_engine_type: VIPER
        operation_metrics: CoordinatorMetrics
    }
    
    component [CollectionStorageIndexCoordinator\n(Collection B)] as CB <<Per-Collection>> COORDINATOR_COLOR {
        + handle_vector_insertion()
        + handle_flush_completion()
        + handle_compaction_completion()
        + get_metrics()
        --
        collection_id: "collection_b"
        storage_engine_type: LSM
        operation_metrics: CoordinatorMetrics
    }
    
    component [CollectionStorageIndexCoordinator\n(Collection N)] as CN <<Per-Collection>> COORDINATOR_COLOR {
        + handle_vector_insertion()
        + handle_flush_completion()
        + handle_compaction_completion()
        + get_metrics()
        --
        collection_id: "collection_n"
        storage_engine_type: VIPER
        operation_metrics: CoordinatorMetrics
    }
}

package "AXIS Adaptive Indexing" {
    component [AxisIndexManager] as AIM <<Shared>> AXIS_COLOR {
        + insert(vector)
        + update_vector_file_reference()
        + rebuild_indexes_after_compaction()
        + ensure_collection_strategy()
        --
        Per-collection strategies maintained internally
    }
    
    component [GlobalIdIndex] as GII AXIS_COLOR
    component [MetadataIndex] as MI AXIS_COLOR
    component [DenseVectorIndex] as DVI AXIS_COLOR
    component [SparseVectorIndex] as SVI AXIS_COLOR
}

package "Storage Engines" {
    component [ViperCoreEngine] as VCE <<Shared>> STORAGE_COLOR {
        + flush_collection_with_memtable_data()
        + apply_quantization_to_batch()
        + do_compact()
        --
        Handles VIPER collections
        Supports quantization (4, 6, 8 bits)
    }
    
    component [LsmTree] as LSM <<Shared>> STORAGE_COLOR {
        + flush()
        + compact()
        --
        Handles LSM collections
        Traditional B-tree structure
    }
}

package "WAL with Collection Partitioning" {
    component [WalManager] as WM WAL_COLOR {
        + insert_batch_with_sync()
        + register_storage_engine()
        --
        Natural collection-based partitioning
    }
    
    component [MemTable A] as MTA <<Collection A>> WAL_COLOR
    component [MemTable B] as MTB <<Collection B>> WAL_COLOR
    component [MemTable N] as MTN <<Collection N>> WAL_COLOR
}

' Relationships
UAS --> SCM : manages
SCM --> CA : creates/manages
SCM --> CB : creates/manages
SCM --> CN : creates/manages

CA --> AIM : collection_a operations
CB --> AIM : collection_b operations  
CN --> AIM : collection_n operations

CA --> VCE : VIPER operations
CB --> LSM : LSM operations
CN --> VCE : VIPER operations

AIM --> GII : delegates to
AIM --> MI : delegates to
AIM --> DVI : delegates to
AIM --> SVI : delegates to

WM --> MTA : collection_a data
WM --> MTB : collection_b data
WM --> MTN : collection_n data

VCE --> MTA : flush from
VCE --> MTN : flush from
LSM --> MTB : flush from

' Flow annotations
note right of SCM
  **Scaling Benefits:**
  • One coordinator per collection
  • Perfect isolation between collections
  • Horizontal scaling ready
  • Code reuse via parameterization
  • Aligns with WAL memtable partitioning
end note

note right of CA
  **Per-Collection Features:**
  • Collection-specific metrics
  • Storage engine type awareness
  • Independent lifecycle management
  • Distributed mode ready
end note

note bottom of WM
  **Natural Partitioning:**
  WAL memtables are already
  partitioned by collection,
  enabling perfect isolation
end note

@enduml